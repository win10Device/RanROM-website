<?php
require_once 'JWT.php';
require_once 'Key.php';
require_once 'ExpiredException.php';
require_once 'BeforeValidException.php';
require_once 'SignatureInvalidException.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Firebase\JWT\SignatureInvalidException;
use Firebase\JWT\BeforeValidException;
use Firebase\JWT\ExpiredException;
use DomainException;
use InvalidArgumentException;
use UnexpectedValueException;



//REMEMBER ME eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
//  .eyJpc3MiOiJodHRwczpcL1wvcWEtYXBpLndlbGx2aWJlLmNvbVwvYXBpXC9hdXRoXC9sb2dpbiIsImlhdCI6MTYzMDQ3OTA5NSwiZXhwIjoxNjMwNDgyNjk1LCJuYmYiOjE2MzA0NzkwOTUsImp0aSI6Imtsa3hHUGpMOVlNTzRSdUsiLCJzdWIiOjc3ODE4LCJwcnYiOiIyM2JkNWM4OTQ5ZjYwMGFkYjM5ZTcwMWM0MDA4NzJkYjdhNTk3NmY3IiwidXNlcnNfaWQiOjc3ODE4LCJtZW1iZXJzX2lkIjo3Nzg4MzMsInByb3h5X3VzZXJfbWVtYmVyc19pZCI6bnVsbH0
//  .TxXwLLu1zWBe7cLLYdFYy3P2HX4AaLgc7WfSRtTgeiI

/* --------------------------------------------------------------------------------------------------------- */

// Public and private keys are expected to be Base64 encoded. The last
// non-empty line is used so that keys can be generated with
// sodium_crypto_sign_keypair(). The secret keys generated by other tools may
// need to be adjusted to match the input expected by libsodium.

$keyPair = sodium_crypto_sign_keypair();

$privateKey = base64_encode(sodium_crypto_sign_secretkey($keyPair));

$publicKey = base64_encode(sodium_crypto_sign_publickey($keyPair));

$key = '1983UWwppOEIpfjPIwpeiPEI0192';
//$key = bin2hex(random_bytes(32));

$payload = [
    'iss' => "https://{$_SERVER['HTTP_HOST']}{$_SERVER['REQUEST_URI']}", //Issuer of the JWT (Who created and signed this token)
    'iat' => time(), //(issued at time): Time at which the JWT was issued; can be used to determine age of the JWT
    'exp' => time() + 3600, //(expiration time): Time after which the JWT expires
    'nbf' => time() - 3600, //(not before time): Time before which the JWT must not be accepted for processing
    'jti' => 'aaaaa', //(JWT ID): Unique identifier; can be used to prevent the JWT from being replayed (allows a token to be used only once)
    'sub' => 'Gen_Client_info_num', //(subject): Subject of the JWT (the user)
    'usr' => 'joe_blogs',
    'usr_id' => '-1',
    'txt' => ''
];

$jwt = JWT::encode($payload, $key, 'HS256');
//$jwt = JWT::encode($payload, $privateKey, 'EdDSA');
echo "<b>Encode:</b><br>" . print_r($jwt, true) . "\n<br><br>";

//$decoded = JWT::decode($jwt, new Key($publicKey, 'EdDSA'));
//echo "<b>Decode:</b><br>" . print_r((array) $decoded, true) . "\n<br>";
echo "<title>" . bin2hex(random_bytes(32)) . "</title>";

try {
    //$decoded = JWT::decode($jwt, new Key($publicKey, 'EdDSA'));
    $decoded = JWT::decode($jwt, new Key($key, 'HS256'));

    echo "<b>Decode:</b><br>" . print_r((array) $decoded, true) . "\n<br>";
} catch (InvalidArgumentException $e) {
    echo "InvalidArgumentException: " . $e->getMessage();
    // provided key/key-array is empty or malformed.
} catch (DomainException $e) {
    echo "DomainException: " . $e->getMessage();
    // provided algorithm is unsupported OR
    // provided key is invalid OR
    // unknown error thrown in openSSL or libsodium OR
    // libsodium is required but not available.
} catch (SignatureInvalidException $e) {
    echo "SignatureArgumentException: " . $e->getMessage();
    // provided JWT signature verification failed.
} catch (BeforeValidException $e) {
    echo "BeforeValidExecption: " . $e->getMessage();
    // provided JWT is trying to be used before "nbf" claim OR
    // provided JWT is trying to be used before "iat" claim.
} catch (ExpiredException $e) {
    echo "ExpiredExcpetion: " . $e->getMessage();
    // provided JWT is trying to be used after "exp" claim.
} catch (UnexpectedValueException $e) {
    echo "UnexpectedValueExcpetion: " . $e->getMessage();
    // provided JWT is malformed OR
    // provided JWT is missing an algorithm / using an unsupported algorithm OR
    // provided JWT algorithm does not match provided key OR
    // provided key ID in key/key-array is empty or invalid.
}


/*// Verify JWT
try {
    $decoded = JWT::decode($jwt, $key, array('HS256'));
    print_r($decoded);
    // JWT is valid
} catch (Exception $e) {
    var_dump($e);
    // JWT is invalid or expired
}
//print_r($jwt);

/*$key = 'eaxample_key';
$payload = [
    'iss' => 'http://example.org',
    'aud' => 'http://example.com',
    'iat' => 1356999524,
    'nbf' => 1357000000
];

/**
 * IMPORTANT:
 * You must specify supported algorithms for your application. See
 * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40
 * for a list of spec-compliant algorithms.
 */
/*$jwt = JWT::encode($payload, $key, 'HS256');
$decoded = JWT::decode($jwt, new Key($key, 'HS256'));

print_r($decoded);

/*
 NOTE: This will now be an object instead of an associative array. To get
 an associative array, you will need to cast it as such:
*/

/*$decoded_array = (array) $decoded;

/**
 * You can add a leeway to account for when there is a clock skew times between
 * the signing and verifying servers. It is recommended that this leeway should
 * not be bigger than a few minutes.
 *
 * Source: http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#nbfDef
 */
/*JWT::$leeway = 60; // $leeway in seconds
$decoded = JWT::decode($jwt, new Key($key, 'HS256'));*/
